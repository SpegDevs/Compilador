int -> INT
x -> IDENTIFIER
, -> COLON
y -> IDENTIFIER
; -> SEMICOLON
str -> STR
s -> IDENTIFIER
; -> SEMICOLON
arr -> ARRAY
[ -> L_BRACKET
5 -> INTEGER
] -> R_BRACKET
boo -> BOO
b -> IDENTIFIER
; -> SEMICOLON
function -> FUNCTION
int -> INT
suma -> IDENTIFIER
( -> L_PARENTHESIS
int -> INT
n1 -> IDENTIFIER
, -> COLON
int -> INT
n2 -> IDENTIFIER
) -> R_PARENTHESIS
{ -> L_BRACE
return -> RETURN
n1 -> IDENTIFIER
+ -> PLUS
n2 -> IDENTIFIER
; -> SEMICOLON
} -> R_BRACE
function -> FUNCTION
dec -> DEC
fun -> IDENTIFIER
( -> L_PARENTHESIS
dec -> DEC
z -> IDENTIFIER
) -> R_PARENTHESIS
{ -> L_BRACE
int -> INT
c -> IDENTIFIER
; -> SEMICOLON
c -> IDENTIFIER
= -> EQUAL
c -> IDENTIFIER
+ -> PLUS
z -> IDENTIFIER
; -> SEMICOLON
return -> RETURN
y -> IDENTIFIER
* -> MULTIPLICATION
c -> IDENTIFIER
; -> SEMICOLON
} -> R_BRACE
arr -> ARRAY
[ -> L_BRACKET
4 -> INTEGER
] -> R_BRACKET
int -> INT
a1 -> IDENTIFIER
; -> SEMICOLON
arr -> ARRAY
[ -> L_BRACKET
3 -> INTEGER
] -> R_BRACKET
str -> STR
s1 -> IDENTIFIER
, -> COLON
s2 -> IDENTIFIER
; -> SEMICOLON
a1 -> IDENTIFIER
[ -> L_BRACKET
0 -> INTEGER
] -> R_BRACKET
= -> EQUAL
4 -> INTEGER
+ -> PLUS
5 -> INTEGER
; -> SEMICOLON
x -> IDENTIFIER
= -> EQUAL
3 -> INTEGER
+ -> PLUS
a1 -> IDENTIFIER
[ -> L_BRACKET
1 -> INTEGER
] -> R_BRACKET
; -> SEMICOLON
x -> IDENTIFIER
= -> EQUAL
2 -> INTEGER
+ -> PLUS
call -> CALL
suma -> IDENTIFIER
( -> L_PARENTHESIS
4 -> INTEGER
, -> COLON
5 -> INTEGER
) -> R_PARENTHESIS
; -> SEMICOLON
call -> CALL
fun -> IDENTIFIER
( -> L_PARENTHESIS
5 -> INTEGER
) -> R_PARENTHESIS
; -> SEMICOLON
x -> IDENTIFIER
= -> EQUAL
2 -> INTEGER
* -> MULTIPLICATION
( -> L_PARENTHESIS
5 -> INTEGER
+ -> PLUS
y -> IDENTIFIER
* -> MULTIPLICATION
( -> L_PARENTHESIS
10 -> INTEGER
+ -> PLUS
y -> IDENTIFIER
) -> R_PARENTHESIS
) -> R_PARENTHESIS
; -> SEMICOLON
if -> IF
( -> L_PARENTHESIS
x -> IDENTIFIER
< -> LESS_THAN
5 -> INTEGER
&& -> AND
y -> IDENTIFIER
== -> EQUAL_EQUAL
3 -> INTEGER
) -> R_PARENTHESIS
{ -> L_BRACE
int -> INT
z -> IDENTIFIER
; -> SEMICOLON
z -> IDENTIFIER
= -> EQUAL
4 -> INTEGER
; -> SEMICOLON
x -> IDENTIFIER
= -> EQUAL
3 -> INTEGER
; -> SEMICOLON
} -> R_BRACE
ifnot -> IFNOT
( -> L_PARENTHESIS
x -> IDENTIFIER
== -> EQUAL_EQUAL
5 -> INTEGER
) -> R_PARENTHESIS
{ -> L_BRACE
} -> R_BRACE
else -> ELSE
{ -> L_BRACE
int -> INT
y -> IDENTIFIER
; -> SEMICOLON
} -> R_BRACE
int -> INT
i -> IDENTIFIER
; -> SEMICOLON
for -> FOR
( -> L_PARENTHESIS
i -> IDENTIFIER
= -> EQUAL
0 -> INTEGER
; -> SEMICOLON
i -> IDENTIFIER
< -> LESS_THAN
5 -> INTEGER
; -> SEMICOLON
i -> IDENTIFIER
= -> EQUAL
i -> IDENTIFIER
+ -> PLUS
1 -> INTEGER
) -> R_PARENTHESIS
{ -> L_BRACE
int -> INT
z -> IDENTIFIER
; -> SEMICOLON
z -> IDENTIFIER
= -> EQUAL
z -> IDENTIFIER
+ -> PLUS
y -> IDENTIFIER
; -> SEMICOLON
} -> R_BRACE
do -> DO
{ -> L_BRACE
x -> IDENTIFIER
= -> EQUAL
x -> IDENTIFIER
+ -> PLUS
1 -> INTEGER
; -> SEMICOLON
} -> R_BRACE
while -> WHILE
( -> L_PARENTHESIS
x -> IDENTIFIER
< -> LESS_THAN
20 -> INTEGER
) -> R_PARENTHESIS
while -> WHILE
( -> L_PARENTHESIS
x -> IDENTIFIER
!= -> NOT_EQUAL
4 -> INTEGER
) -> R_PARENTHESIS
{ -> L_BRACE
int -> INT
abc -> IDENTIFIER
; -> SEMICOLON
abc -> IDENTIFIER
= -> EQUAL
5 -> INTEGER
* -> MULTIPLICATION
x -> IDENTIFIER
; -> SEMICOLON
} -> R_BRACE
str -> STR
a -> IDENTIFIER
; -> SEMICOLON
a -> IDENTIFIER
= -> EQUAL
"hola" -> STRING
; -> SEMICOLON
x -> IDENTIFIER
= -> EQUAL
a -> IDENTIFIER
+ -> PLUS
"jkl" -> STRING
; -> SEMICOLON
char -> CHAR
c -> IDENTIFIER
; -> SEMICOLON
c -> IDENTIFIER
= -> EQUAL
'a' -> CHARACTER
; -> SEMICOLON
boo -> BOO
b -> IDENTIFIER
; -> SEMICOLON
b -> IDENTIFIER
= -> EQUAL
true -> TRUE
; -> SEMICOLON
dec -> DEC
n1 -> IDENTIFIER
; -> SEMICOLON
n1 -> IDENTIFIER
= -> EQUAL
6.7 -> DECIMAL
; -> SEMICOLON
x -> IDENTIFIER
= -> EQUAL
x -> IDENTIFIER
* -> MULTIPLICATION
n1 -> IDENTIFIER
; -> SEMICOLON
while -> WHILE
( -> L_PARENTHESIS
n1 -> IDENTIFIER
>= -> GREATER_THAN_EQUAL
5 -> INTEGER
) -> R_PARENTHESIS
{ -> L_BRACE
if -> IF
( -> L_PARENTHESIS
x -> IDENTIFIER
== -> EQUAL_EQUAL
3 -> INTEGER
) -> R_PARENTHESIS
{ -> L_BRACE
for -> FOR
( -> L_PARENTHESIS
x -> IDENTIFIER
= -> EQUAL
0 -> INTEGER
; -> SEMICOLON
x -> IDENTIFIER
< -> LESS_THAN
3 -> INTEGER
; -> SEMICOLON
x -> IDENTIFIER
= -> EQUAL
x -> IDENTIFIER
+ -> PLUS
1 -> INTEGER
) -> R_PARENTHESIS
{ -> L_BRACE
call -> CALL
fun -> IDENTIFIER
( -> L_PARENTHESIS
4 -> INTEGER
) -> R_PARENTHESIS
; -> SEMICOLON
} -> R_BRACE
} -> R_BRACE
} -> R_BRACE
